/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"
#include "postencoding.h"

#include "mcu_comms.h"



flag Setup_Type_version_Equal(const Setup_Type_version* pVal1, const Setup_Type_version* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Setup_Type_Equal(const Setup_Type* pVal1, const Setup_Type* pVal2)
{
	flag ret=TRUE;

    ret = Setup_Type_version_Equal((&(pVal1->version)), (&(pVal2->version)));

	return ret;

}

flag Setup_Type_version_IsConstraintValid(const Setup_Type_version* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Setup_Type_IsConstraintValid(const Setup_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Setup_Type_version_IsConstraintValid((&(pVal->version)), pErrCode);

	return ret;
}

void Setup_Type_version_Initialize(Setup_Type_version* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void Setup_Type_Initialize(Setup_Type* pVal)
{
	(void)pVal;



	/*set version */
	Setup_Type_version_Initialize((&(pVal->version)));
}

flag Setup_Type_ACN_Encode(const Setup_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Setup_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode version */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->version), 0, 65535);
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag Setup_Type_ACN_Decode(Setup_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode version */
	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->version)), 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SETUP_TYPE_VERSION;

    return ret && Setup_Type_IsConstraintValid(pVal, pErrCode);
}


flag Inputs_Type_stepper_fault_Equal(const Inputs_Type_stepper_fault* pVal1, const Inputs_Type_stepper_fault* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++)
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag Inputs_Type_adc_sequential_id_Equal(const Inputs_Type_adc_sequential_id* pVal1, const Inputs_Type_adc_sequential_id* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Inputs_Type_adc_temp_value_elem_Equal(const Inputs_Type_adc_temp_value_elem* pVal1, const Inputs_Type_adc_temp_value_elem* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Inputs_Type_adc_temp_value_Equal(const Inputs_Type_adc_temp_value* pVal1, const Inputs_Type_adc_temp_value* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 4; i1++)
    {
    	ret = Inputs_Type_adc_temp_value_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

flag Inputs_Type_fan_tach_count_elem_Equal(const Inputs_Type_fan_tach_count_elem* pVal1, const Inputs_Type_fan_tach_count_elem* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Inputs_Type_fan_tach_count_Equal(const Inputs_Type_fan_tach_count* pVal1, const Inputs_Type_fan_tach_count* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 4; i1++)
    {
    	ret = Inputs_Type_fan_tach_count_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

flag Inputs_Type_Equal(const Inputs_Type* pVal1, const Inputs_Type* pVal2)
{
	flag ret=TRUE;

    ret = Inputs_Type_stepper_fault_Equal((&(pVal1->stepper_fault)), (&(pVal2->stepper_fault)));

    if (ret) {
        ret = Inputs_Type_adc_sequential_id_Equal((&(pVal1->adc_sequential_id)), (&(pVal2->adc_sequential_id)));

        if (ret) {
            ret = Inputs_Type_adc_temp_value_Equal((&(pVal1->adc_temp_value)), (&(pVal2->adc_temp_value)));

            if (ret) {
                ret = Inputs_Type_fan_tach_count_Equal((&(pVal1->fan_tach_count)), (&(pVal2->fan_tach_count)));

            }

        }

    }

	return ret;

}

flag Inputs_Type_stepper_fault_IsConstraintValid(const Inputs_Type_stepper_fault* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Inputs_Type_adc_sequential_id_IsConstraintValid(const Inputs_Type_adc_sequential_id* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Inputs_Type_adc_temp_value_elem_IsConstraintValid(const Inputs_Type_adc_temp_value_elem* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Inputs_Type_adc_temp_value_IsConstraintValid(const Inputs_Type_adc_temp_value* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 4; i1++)
    {
    	ret = Inputs_Type_adc_temp_value_elem_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag Inputs_Type_fan_tach_count_elem_IsConstraintValid(const Inputs_Type_fan_tach_count_elem* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Inputs_Type_fan_tach_count_IsConstraintValid(const Inputs_Type_fan_tach_count* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 4; i1++)
    {
    	ret = Inputs_Type_fan_tach_count_elem_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag Inputs_Type_IsConstraintValid(const Inputs_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Inputs_Type_stepper_fault_IsConstraintValid((&(pVal->stepper_fault)), pErrCode);
    if (ret) {
        ret = Inputs_Type_adc_sequential_id_IsConstraintValid((&(pVal->adc_sequential_id)), pErrCode);
        if (ret) {
            ret = Inputs_Type_adc_temp_value_IsConstraintValid((&(pVal->adc_temp_value)), pErrCode);
            if (ret) {
                ret = Inputs_Type_fan_tach_count_IsConstraintValid((&(pVal->fan_tach_count)), pErrCode);
            }   /*COVERAGE_IGNORE*/
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void Inputs_Type_stepper_fault_Initialize(Inputs_Type_stepper_fault* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    pVal->arr[i1] = FALSE;
	    i1 = i1 + 1;
	}

}
void Inputs_Type_adc_sequential_id_Initialize(Inputs_Type_adc_sequential_id* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void Inputs_Type_adc_temp_value_elem_Initialize(Inputs_Type_adc_temp_value_elem* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void Inputs_Type_adc_temp_value_Initialize(Inputs_Type_adc_temp_value* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    Inputs_Type_adc_temp_value_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void Inputs_Type_fan_tach_count_elem_Initialize(Inputs_Type_fan_tach_count_elem* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void Inputs_Type_fan_tach_count_Initialize(Inputs_Type_fan_tach_count* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    Inputs_Type_fan_tach_count_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void Inputs_Type_Initialize(Inputs_Type* pVal)
{
	(void)pVal;



	/*set stepper_fault */
	Inputs_Type_stepper_fault_Initialize((&(pVal->stepper_fault)));
	/*set adc_sequential_id */
	Inputs_Type_adc_sequential_id_Initialize((&(pVal->adc_sequential_id)));
	/*set adc_temp_value */
	Inputs_Type_adc_temp_value_Initialize((&(pVal->adc_temp_value)));
	/*set fan_tach_count */
	Inputs_Type_fan_tach_count_Initialize((&(pVal->fan_tach_count)));
}

flag Inputs_Type_ACN_Encode(const Inputs_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? Inputs_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode stepper_fault */
	    for(i1=0; (i1 < (int)6) && ret; i1++)
	    {
	    	BitStream_AppendBit(pBitStrm,pVal->stepper_fault.arr[i1]);
	    }
	    if (ret) {
	        /*Encode adc_sequential_id */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->adc_sequential_id), 0, 65535);
	        if (ret) {
	            /*Encode adc_temp_value */
	            for(i1=0; (i1 < (int)4) && ret; i1++)
	            {
	            	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->adc_temp_value.arr[i1]), 0, 65535);
	            }
	            if (ret) {
	                /*Encode fan_tach_count */
	                for(i1=0; (i1 < (int)4) && ret; i1++)
	                {
	                	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->fan_tach_count.arr[i1]), 0, 65535);
	                }
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag Inputs_Type_ACN_Decode(Inputs_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode stepper_fault */
	for(i1=0; (i1 < (int)6) && ret; i1++)
	{
		ret = BitStream_ReadBit(pBitStrm, (&(pVal->stepper_fault.arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_INPUTS_TYPE_STEPPER_FAULT_ELM;
	}
	if (ret) {
	    /*Decode adc_sequential_id */
	    ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->adc_sequential_id)), 0, 65535);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_INPUTS_TYPE_ADC_SEQUENTIAL_ID;
	    if (ret) {
	        /*Decode adc_temp_value */
	        for(i1=0; (i1 < (int)4) && ret; i1++)
	        {
	        	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->adc_temp_value.arr[i1])), 0, 65535);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_INPUTS_TYPE_ADC_TEMP_VALUE_ELM;
	        }
	        if (ret) {
	            /*Decode fan_tach_count */
	            for(i1=0; (i1 < (int)4) && ret; i1++)
	            {
	            	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->fan_tach_count.arr[i1])), 0, 65535);
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_INPUTS_TYPE_FAN_TACH_COUNT_ELM;
	            }
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && Inputs_Type_IsConstraintValid(pVal, pErrCode);
}


flag Outputs_Type_stepper_output_enable_Equal(const Outputs_Type_stepper_output_enable* pVal1, const Outputs_Type_stepper_output_enable* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++)
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag Outputs_Type_stepper_enable_Equal(const Outputs_Type_stepper_enable* pVal1, const Outputs_Type_stepper_enable* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++)
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag Outputs_Type_fan_pwm_elem_Equal(const Outputs_Type_fan_pwm_elem* pVal1, const Outputs_Type_fan_pwm_elem* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Outputs_Type_fan_pwm_Equal(const Outputs_Type_fan_pwm* pVal1, const Outputs_Type_fan_pwm* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 4; i1++)
    {
    	ret = Outputs_Type_fan_pwm_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

flag Outputs_Type_Equal(const Outputs_Type* pVal1, const Outputs_Type* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->heater_enable == pVal2->heater_enable);

    if (ret) {
        ret = Outputs_Type_stepper_output_enable_Equal((&(pVal1->stepper_output_enable)), (&(pVal2->stepper_output_enable)));

        if (ret) {
            ret = Outputs_Type_stepper_enable_Equal((&(pVal1->stepper_enable)), (&(pVal2->stepper_enable)));

            if (ret) {
                ret = Outputs_Type_fan_pwm_Equal((&(pVal1->fan_pwm)), (&(pVal2->fan_pwm)));

            }

        }

    }

	return ret;

}

flag Outputs_Type_stepper_output_enable_IsConstraintValid(const Outputs_Type_stepper_output_enable* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Outputs_Type_stepper_enable_IsConstraintValid(const Outputs_Type_stepper_enable* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Outputs_Type_fan_pwm_elem_IsConstraintValid(const Outputs_Type_fan_pwm_elem* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 639UL);
    *pErrCode = ret ? 0 :  ERR_OUTPUTS_TYPE_FAN_PWM_ELM;

	return ret;
}

flag Outputs_Type_fan_pwm_IsConstraintValid(const Outputs_Type_fan_pwm* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 4; i1++)
    {
    	ret = Outputs_Type_fan_pwm_elem_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag Outputs_Type_IsConstraintValid(const Outputs_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Outputs_Type_stepper_output_enable_IsConstraintValid((&(pVal->stepper_output_enable)), pErrCode);
    if (ret) {
        ret = Outputs_Type_stepper_enable_IsConstraintValid((&(pVal->stepper_enable)), pErrCode);
        if (ret) {
            ret = Outputs_Type_fan_pwm_IsConstraintValid((&(pVal->fan_pwm)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void Outputs_Type_stepper_output_enable_Initialize(Outputs_Type_stepper_output_enable* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    pVal->arr[i1] = FALSE;
	    i1 = i1 + 1;
	}

}
void Outputs_Type_stepper_enable_Initialize(Outputs_Type_stepper_enable* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    pVal->arr[i1] = FALSE;
	    i1 = i1 + 1;
	}

}
void Outputs_Type_fan_pwm_elem_Initialize(Outputs_Type_fan_pwm_elem* pVal)
{
	(void)pVal;


	(*(pVal)) = 0UL;
}
void Outputs_Type_fan_pwm_Initialize(Outputs_Type_fan_pwm* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 4) {
	    Outputs_Type_fan_pwm_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void Outputs_Type_Initialize(Outputs_Type* pVal)
{
	(void)pVal;



	/*set heater_enable */
	pVal->heater_enable = FALSE;
	/*set stepper_output_enable */
	Outputs_Type_stepper_output_enable_Initialize((&(pVal->stepper_output_enable)));
	/*set stepper_enable */
	Outputs_Type_stepper_enable_Initialize((&(pVal->stepper_enable)));
	/*set fan_pwm */
	Outputs_Type_fan_pwm_Initialize((&(pVal->fan_pwm)));
}

flag Outputs_Type_ACN_Encode(const Outputs_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? Outputs_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode heater_enable */
	    BitStream_AppendBit(pBitStrm,pVal->heater_enable);
	    if (ret) {
	        /*Encode stepper_output_enable */
	        for(i1=0; (i1 < (int)6) && ret; i1++)
	        {
	        	BitStream_AppendBit(pBitStrm,pVal->stepper_output_enable.arr[i1]);
	        }
	        if (ret) {
	            /*Encode stepper_enable */
	            for(i1=0; (i1 < (int)6) && ret; i1++)
	            {
	            	BitStream_AppendBit(pBitStrm,pVal->stepper_enable.arr[i1]);
	            }
	            if (ret) {
	                /*Encode fan_pwm */
	                for(i1=0; (i1 < (int)4) && ret; i1++)
	                {
	                	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(pVal->fan_pwm.arr[i1]), 0, 639);
	                }
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag Outputs_Type_ACN_Decode(Outputs_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode heater_enable */
	ret = BitStream_ReadBit(pBitStrm, (&(pVal->heater_enable)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OUTPUTS_TYPE_HEATER_ENABLE;
	if (ret) {
	    /*Decode stepper_output_enable */
	    for(i1=0; (i1 < (int)6) && ret; i1++)
	    {
	    	ret = BitStream_ReadBit(pBitStrm, (&(pVal->stepper_output_enable.arr[i1])));
	    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE_ELM;
	    }
	    if (ret) {
	        /*Decode stepper_enable */
	        for(i1=0; (i1 < (int)6) && ret; i1++)
	        {
	        	ret = BitStream_ReadBit(pBitStrm, (&(pVal->stepper_enable.arr[i1])));
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_ENABLE_ELM;
	        }
	        if (ret) {
	            /*Decode fan_pwm */
	            for(i1=0; (i1 < (int)4) && ret; i1++)
	            {
	            	ret = BitStream_DecodeConstraintPosWholeNumberUInt16(pBitStrm, (&(pVal->fan_pwm.arr[i1])), 0, 639);
	            	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OUTPUTS_TYPE_FAN_PWM_ELM;
	            }
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && Outputs_Type_IsConstraintValid(pVal, pErrCode);
}


flag Packet_Data_Type_Equal(const Packet_Data_Type* pVal1, const Packet_Data_Type* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind)
    	{
    	case setup_PRESENT:
    		ret = Setup_Type_Equal((&(pVal1->u.setup)), (&(pVal2->u.setup)));
    		break;
    	case inputs_PRESENT:
    		ret = Inputs_Type_Equal((&(pVal1->u.inputs)), (&(pVal2->u.inputs)));
    		break;
    	case outputs_PRESENT:
    		ret = Outputs_Type_Equal((&(pVal1->u.outputs)), (&(pVal2->u.outputs)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag Packet_Data_Type_IsConstraintValid(const Packet_Data_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == setup_PRESENT) {
    	ret = Setup_Type_IsConstraintValid((&(pVal->u.setup)), pErrCode);
    }
    if (ret) {
        if (pVal->kind == inputs_PRESENT) {
        	ret = Inputs_Type_IsConstraintValid((&(pVal->u.inputs)), pErrCode);
        }
        if (ret) {
            if (pVal->kind == outputs_PRESENT) {
            	ret = Outputs_Type_IsConstraintValid((&(pVal->u.outputs)), pErrCode);
            }
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void Packet_Data_Type_Initialize(Packet_Data_Type* pVal)
{
	(void)pVal;


	pVal->kind = setup_PRESENT;
	Setup_Type_Initialize((&(pVal->u.setup)));
}

flag Packet_Data_Type_ACN_Encode(const Packet_Data_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Packet_Data_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch(pVal->kind)
	    {
	    case setup_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	    	ret = Setup_Type_ACN_Encode((&(pVal->u.setup)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case inputs_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	    	ret = Inputs_Type_ACN_Encode((&(pVal->u.inputs)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case outputs_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	    	ret = Outputs_Type_ACN_Encode((&(pVal->u.outputs)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_ENCODE_PACKET_DATA_TYPE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    } /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag Packet_Data_Type_ACN_Decode(Packet_Data_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint MCU_COMMS_Packet_Data_Type_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &MCU_COMMS_Packet_Data_Type_index_tmp, 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PACKET_DATA_TYPE;
	if (ret) {
	    switch(MCU_COMMS_Packet_Data_Type_index_tmp)
	    {
	    case 0:
	    	pVal->kind = setup_PRESENT;
	    	ret = Setup_Type_ACN_Decode((&(pVal->u.setup)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = inputs_PRESENT;
	    	ret = Inputs_Type_ACN_Decode((&(pVal->u.inputs)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = outputs_PRESENT;
	    	ret = Outputs_Type_ACN_Decode((&(pVal->u.outputs)), pBitStrm, pErrCode);
	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PACKET_DATA_TYPE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && Packet_Data_Type_IsConstraintValid(pVal, pErrCode);
}


flag Packet_Type_Equal(const Packet_Type* pVal1, const Packet_Type* pVal2)
{
	flag ret=TRUE;

    ret = Packet_Data_Type_Equal((&(pVal1->packet_data)), (&(pVal2->packet_data)));

	return ret;

}

flag Packet_Type_IsConstraintValid(const Packet_Type* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Packet_Data_Type_IsConstraintValid((&(pVal->packet_data)), pErrCode);

	return ret;
}

void Packet_Type_Initialize(Packet_Type* pVal)
{
	(void)pVal;



	/*set packet_data */
	Packet_Data_Type_Initialize((&(pVal->packet_data)));
}

flag Packet_Type_ACN_Encode(const Packet_Type* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	Packet_Type_extension_function_positions bitStreamPositions_1;
	BitStream bitStreamPositions_start1;
	Packet_Data_Kind Packet_Type_packet_data_kind;
	flag Packet_Type_packet_data_kind_is_initialized=FALSE;
	uint8_t intVal_Packet_Type_packet_data_kind;
    *pErrCode = 0;
	ret = bCheckConstraints ? Packet_Type_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    bitStreamPositions_start1 = *pBitStrm; //save the initial position of the bit stream at
	    if (ret) {
	        /*Encode Packet_Type_body_length_in_bytes */
	        bitStreamPositions_1.Packet_Type_body_length_in_bytes = *pBitStrm; //save position of the bit stream
	        {
	        	static byte tmp[] = {0x00,0x00};
	        	BitStream_AppendBits(pBitStrm, tmp, 16);
	        }
	        if (ret) {
	            switch (pVal->packet_data.kind) {
	                case setup_PRESENT:
	                    Packet_Type_packet_data_kind_is_initialized = TRUE;
	                	Packet_Type_packet_data_kind = setup;
	                    break;
	                case inputs_PRESENT:
	                    Packet_Type_packet_data_kind_is_initialized = TRUE;
	                	Packet_Type_packet_data_kind = inputs;
	                    break;
	                case outputs_PRESENT:
	                    Packet_Type_packet_data_kind_is_initialized = TRUE;
	                	Packet_Type_packet_data_kind = outputs;
	                    break;
	                default:
	                    ret = FALSE;                            /*COVERAGE_IGNORE*/
	            }
	            if (ret) {
	                /*Encode Packet_Type_packet_data_kind */
	                if (Packet_Type_packet_data_kind_is_initialized) {
	                    ret = TRUE;
	                    switch(Packet_Type_packet_data_kind) {
	                        case setup:
	                            intVal_Packet_Type_packet_data_kind = 0UL;
	                            break;
	                        case inputs:
	                            intVal_Packet_Type_packet_data_kind = 1UL;
	                            break;
	                        case outputs:
	                            intVal_Packet_Type_packet_data_kind = 2UL;
	                            break;
	                        default:                                    /*COVERAGE_IGNORE*/
	                            ret = FALSE;                            /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_KIND;                 /*COVERAGE_IGNORE*/
	                    }
	                    if (ret) {
	                    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, (asn1SccUint)(intVal_Packet_Type_packet_data_kind));
	                    }
	                } else {
	                    *pErrCode = ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_KIND_UNINITIALIZED;         /*COVERAGE_IGNORE*/
	                    ret = FALSE;                    /*COVERAGE_IGNORE*/
	                }
	                if (ret) {
	                    /*Encode packet_data */
	                    switch(pVal->packet_data.kind)
	                    {
	                        case setup_PRESENT:
	                        	ret = Setup_Type_ACN_Encode((&(pVal->packet_data.u.setup)), pBitStrm, pErrCode, FALSE);
	                        	break;
	                        case inputs_PRESENT:
	                        	ret = Inputs_Type_ACN_Encode((&(pVal->packet_data.u.inputs)), pBitStrm, pErrCode, FALSE);
	                        	break;
	                        case outputs_PRESENT:
	                        	ret = Outputs_Type_ACN_Encode((&(pVal->packet_data.u.outputs)), pBitStrm, pErrCode, FALSE);
	                        	break;
	                    default:
	                        *pErrCode = ERR_INVALID_ENUM_VALUE;         /*COVERAGE_IGNORE*/
	                        ret = FALSE;                    /*COVERAGE_IGNORE*/
	                    }
	                    if (ret) {
	                        /*Encode Packet_Type_packet_crc32 */
	                        Acn_AlignToNextByte(pBitStrm, TRUE);
	                        bitStreamPositions_1.Packet_Type_packet_crc32 = *pBitStrm; //save position of the bit stream
	                        {
	                        	static byte tmp[] = {0x00,0x00,0x00,0x00};
	                        	BitStream_AppendBits(pBitStrm, tmp, 32);
	                        }
	                        if (ret) {
	                            my_encoding_patcher(pVal, &bitStreamPositions_start1, &bitStreamPositions_1, pBitStrm);
	                        }   /*COVERAGE_IGNORE*/
	                    }   /*COVERAGE_IGNORE*/
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag Packet_Type_ACN_Decode(Packet_Type* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	Packet_Type_extension_function_positions bitStreamPositions_1;
	BitStream bitStreamPositions_start1;
	Packet_Data_Kind Packet_Type_packet_data_kind;
	uint8_t intVal_Packet_Type_packet_data_kind;

	ret = TRUE;
	bitStreamPositions_start1 = *pBitStrm; //save the initial position of the bit stream
	if (ret) {
	    /*Decode Packet_Type_body_length_in_bytes */
	    bitStreamPositions_1.Packet_Type_body_length_in_bytes = *pBitStrm; //save position of the bit stream
	    ret = BitStream_ReadBitPattern_ignore_value(pBitStrm, 16);

	    if (ret) {
	        /*Decode Packet_Type_packet_data_kind */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize_8UInt8(pBitStrm, (&(intVal_Packet_Type_packet_data_kind)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_KIND;
	        if (ret) {
	            switch (intVal_Packet_Type_packet_data_kind) {
	                case 0:
	                    Packet_Type_packet_data_kind = setup;
	                    break;
	                case 1:
	                    Packet_Type_packet_data_kind = inputs;
	                    break;
	                case 2:
	                    Packet_Type_packet_data_kind = outputs;
	                    break;
	            default:                                    /*COVERAGE_IGNORE*/
	                ret = FALSE;                            /*COVERAGE_IGNORE*/
	                *pErrCode = ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_KIND;                 /*COVERAGE_IGNORE*/
	            }
	        } /*COVERAGE_IGNORE*/
	        if (ret) {
	            /*Decode packet_data */
	            switch(Packet_Type_packet_data_kind)
	            {
	                case setup:
	                	pVal->packet_data.kind = setup_PRESENT;
	                	ret = Setup_Type_ACN_Decode((&(pVal->packet_data.u.setup)), pBitStrm, pErrCode);
	                	break;
	                case inputs:
	                	pVal->packet_data.kind = inputs_PRESENT;
	                	ret = Inputs_Type_ACN_Decode((&(pVal->packet_data.u.inputs)), pBitStrm, pErrCode);
	                	break;
	                case outputs:
	                	pVal->packet_data.kind = outputs_PRESENT;
	                	ret = Outputs_Type_ACN_Decode((&(pVal->packet_data.u.outputs)), pBitStrm, pErrCode);
	                	break;
	            default:
	                *pErrCode = ERR_INVALID_ENUM_VALUE;         /*COVERAGE_IGNORE*/
	                ret = FALSE;                    /*COVERAGE_IGNORE*/
	            }
	            if (ret) {
	                /*Decode Packet_Type_packet_crc32 */
	                Acn_AlignToNextByte(pBitStrm, FALSE);
	                bitStreamPositions_1.Packet_Type_packet_crc32 = *pBitStrm; //save position of the bit stream
	                ret = BitStream_ReadBitPattern_ignore_value(pBitStrm, 32);

	                if (ret) {
	                    ret = my_crc_validator(pVal, &bitStreamPositions_start1, &bitStreamPositions_1, pBitStrm, pErrCode);
	                }   /*COVERAGE_IGNORE*/
	            }   /*COVERAGE_IGNORE*/
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && Packet_Type_IsConstraintValid(pVal, pErrCode);
}


flag Packet_Data_Kind_Equal(const Packet_Data_Kind* pVal1, const Packet_Data_Kind* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Packet_Data_Kind_IsConstraintValid(const Packet_Data_Kind* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == setup)) || (((*(pVal)) == inputs)))) || (((*(pVal)) == outputs)));
    *pErrCode = ret ? 0 :  ERR_PACKET_DATA_KIND;

	return ret;
}

void Packet_Data_Kind_Initialize(Packet_Data_Kind* pVal)
{
	(void)pVal;


	(*(pVal)) = setup;
}

flag Packet_Data_Kind_ACN_Encode(const Packet_Data_Kind* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	uint8_t intVal_pVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? Packet_Data_Kind_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) {
	        case setup:
	            intVal_pVal = 0UL;
	            break;
	        case inputs:
	            intVal_pVal = 1UL;
	            break;
	        case outputs:
	            intVal_pVal = 2UL;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PACKET_DATA_KIND;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (asn1SccUint)(intVal_pVal), 0, 2);
	    }
    } /*COVERAGE_IGNORE*/


    return ret;
}

flag Packet_Data_Kind_ACN_Decode(Packet_Data_Kind* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	uint8_t intVal_pVal;

	ret = BitStream_DecodeConstraintPosWholeNumberUInt8(pBitStrm, (&(intVal_pVal)), 0, 2);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PACKET_DATA_KIND;
	if (ret) {
	    switch (intVal_pVal) {
	        case 0:
	            (*(pVal)) = setup;
	            break;
	        case 1:
	            (*(pVal)) = inputs;
	            break;
	        case 2:
	            (*(pVal)) = outputs;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PACKET_DATA_KIND;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && Packet_Data_Kind_IsConstraintValid(pVal, pErrCode);
}


